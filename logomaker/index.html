<!DOCTYPE html>
<html>
<head>
    <title>Strategy Logo Maker</title>
    <link rel="icon" href="favicon.ico" type="image/x-icon">
    <link href="https://fonts.googleapis.com/css2?family=Lexend:wght@400;700&family=Inter:wght@400&display=swap" rel="stylesheet">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta property="og:title" content="Strategy Logo Maker">
    <meta property="og:description" content="Strategy Logo Makers made by @LaDoger21">
    <meta property="og:type" content="gallery">
    <meta property="og:url" content="https://ladoger.art/logomaker">
    <meta property="og:image" content="https://ladoger.art/logomaker/logomaker.jpg">
    <meta property="og:image:width" content="1200">
    <meta property="og:image:height" content="600">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Strategy Logo Maker">
    <meta name="twitter:description" content="Strategy Logo Maker made by @LaDoger21">
    <meta name="twitter:image" content="https://ladoger.art/logomaker/logomaker.jpg">
    <meta name="twitter:site" content="@LaDoger21">

    <style>
        :root {
            --input-height: 44px;
            --input-border-width: 3px;
            --input-padding: 10px; /* Padding inside the wrapper */
            --border-radius: 8px;
            --standard-gap: 12px; /* Unified gap */
            --button-size: 24px;
            --button-margin: 6px;
        }

        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            font-family: 'Lexend', sans-serif;
            margin: 0;
            padding: 20px 20px var(--standard-gap); /* Added bottom padding */
            min-height: 100vh;
            box-sizing: border-box;
            background-color: #FFFFFF;
        }

        .container {
            width: 100%;
            max-width: 800px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: var(--standard-gap); /* Consistent gap for direct children */
            flex-grow: 1; /* Pushes footer down if content is short */
        }

        h2 {
            font-size: 2.5em;
            font-weight: 700;
            margin: 0;
            color: #FA660F;
            letter-spacing: -0.1em;
            padding-bottom: 5px; /* Keep specific bottom padding for heading */
        }

        .text-input-wrapper,
        .signature-input-wrapper,
        .color-picker-label {
            box-sizing: border-box;
            border: var(--input-border-width) solid transparent;
            border-radius: var(--border-radius);
            background: linear-gradient(var(--bg-color, #FFFFFF), var(--bg-color, #FFFFFF)) padding-box,
                        linear-gradient(to right, #FFB6C1, #FFDAB9, #FFDEAD, #E6E6FA, #B0E0E6, #98FB98, #D8BFD8) border-box;
            animation: gradientShift 8s linear infinite;
            background-size: 100% 100%, 200% 100%;
            height: var(--input-height);
            position: relative;
            /* Flexbox for vertical centering */
            display: flex;
            align-items: center;
            padding: 0 var(--input-padding); /* Padding horizontal applied to wrapper */
        }

        /* Specific background colors */
        .text-input-wrapper { --bg-color: #FFFFFF; }
        .signature-input-wrapper { --bg-color: #f8f8f8; }
        .color-picker-label { padding: 0; } /* Color picker label needs no padding */

        @keyframes gradientShift {
            0% { background-position: 0% 0%, 0% 0%; }
            100% { background-position: 0% 0%, 200% 0%; }
        }

        .text-input-wrapper {
            width: 100%;
            max-width: 300px;
        }

        /* Input text styling */
        .text-input-wrapper input[type="text"]#wordInput,
        .signature-input-wrapper input[type="text"]#signatureInput {
            flex-grow: 1; /* Allow input to take available space */
            height: auto; /* Let flexbox determine height */
            background: transparent;
            border: none;
            outline: none;
            box-sizing: border-box;
            font-size: 16px;
            font-family: 'Lexend', sans-serif;
            font-weight: 400;
            text-align: center;
            /* Removed height: 100% and padding */
            line-height: normal; /* Reset line height for better centering */
        }

        .signature-input-wrapper input[type="text"]#signatureInput {
            font-size: 14px;
            font-family: 'Inter', sans-serif;
            color: #555;
        }

        .signature-input-wrapper input[type="text"]::placeholder {
            color: #aaa;
        }

        #signatureToggleBtn {
            position: absolute; /* Keep absolute for positioning within wrapper */
            right: var(--button-margin);
            top: 50%;
            transform: translateY(-50%);
            width: var(--button-size);
            height: var(--button-size);
            padding: 0;
            border: 1px solid #ccc;
            border-radius: calc(var(--border-radius) / 2.5);
            background-color: #f0f0f0;
            color: #555;
            font-size: 14px;
            line-height: 1;
            font-family: 'Segoe UI Emoji', 'Apple Color Emoji', 'Noto Color Emoji', sans-serif;
            font-weight: normal;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background-color 0.2s, border-color 0.2s;
            z-index: 2;
            /* Make sure button doesn't stretch */
            flex-shrink: 0;
        }

        #signatureToggleBtn:hover {
            background-color: #e0e0e0;
            border-color: #aaa;
        }

        #signatureToggleBtn.active {
            background-color: #d0d0d0;
            border-color: #888;
        }

        .signature-input-wrapper {
            width: 100%;
            max-width: 300px;
            display: none;
            /* Removed margin-top, relying on container gap */
        }

        .signature-input-wrapper.visible {
            display: flex; /* Use flex when visible for centering */
        }

        .color-picker-container {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
            max-width: 300px;
            gap: var(--standard-gap); /* Use standard gap */
        }

        .color-picker-label {
            flex: 1;
            display: block; /* Keep display block */
            min-width: 0;
            /* Ensure label wrapper height matches input height for consistency */
            height: var(--input-height);
        }

        .color-picker-label input[type="color"] {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            opacity: 0;
            cursor: pointer;
            border: none;
            padding: 0;
            margin: 0;
        }

        .canvas-row {
            display: flex;
            flex-wrap: nowrap;
            gap: var(--standard-gap); /* Use standard gap */
            width: 100%;
            max-width: 800px; /* Keep max-width for desktop */
        }

        canvas {
            width: 390px; /* Default width, will be adjusted by JS */
            height: auto;
            border: 1px solid #ccc;
            display: block;
        }

        .transparent-bg {
            background-image: linear-gradient(45deg, #ccc 25%, transparent 25%),
                              linear-gradient(-45deg, #ccc 25%, transparent 25%),
                              linear-gradient(45deg, transparent 75%, #ccc 75%),
                              linear-gradient(-45deg, transparent 75%, #ccc 75%);
            background-size: 20px 20px;
            background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
        }

        footer {
            width: 100%;
            text-align: center;
            padding: 10px 0 0; /* Remove bottom padding here, body has it */
            background-color: #FFFFFF;
            font-weight: 400;
            /* Removed margin-top, relying on container gap */
        }

        footer a {
            color: #FA660F;
            text-decoration: none;
        }

        footer a b {
            font-weight: 700;
        }

        footer a:hover {
            text-decoration: underline;
        }

        /* ----------- MOBILE STYLES ----------- */
        @media (max-width: 600px) {
            h2 {
                font-size: 1.8em;
                text-align: center;
            }

            .text-input-wrapper,
            .signature-input-wrapper,
            .color-picker-container {
                max-width: 100%; /* Allow full width on mobile */
            }

            /* Use grid for mobile ordering */
            .container {
                display: grid;
                grid-template-columns: 1fr; /* Single column layout */
                gap: var(--standard-gap); /* Consistent gap */
            }

            .canvas-row {
                display: contents; /* Let canvas elements be direct grid children */
            }

            canvas {
                width: 100% !important; /* Force full width */
                max-width: 100%;
                height: auto !important; /* Maintain aspect ratio */
                cursor: pointer;
            }

            /* --- Mobile Ordering using grid order --- */
            /* Keep top elements first */
            h2 { order: 1; }
            .text-input-wrapper { order: 2; }
            .signature-input-wrapper { order: 3; }
            .color-picker-container { order: 4; }

            /* Canvas Ordering: Solid backgrounds first, then transparent */
            /* Solid Backgrounds (16x9 then Square) */
            #canvas1 { order: 5; } /* Black on Orange */
            #canvas2 { order: 6; } /* Orange on White */
            #canvas3 { order: 7; } /* White on Black */
            #canvas7 { order: 8; } /* Square: Black on Orange */
            #canvas8 { order: 9; } /* Square: Orange on White */
            #canvas9 { order: 10; } /* Square: White on Black */

            /* Transparent Backgrounds (16x9 then Square) */
            #canvas4 { order: 11; } /* Black on Transparent */
            #canvas5 { order: 12; } /* Orange on Transparent */
            #canvas6 { order: 13; } /* White on Transparent */
            #canvas10 { order: 14; } /* Square: Black on Transparent */
            #canvas11 { order: 15; } /* Square: Orange on Transparent */
            #canvas12 { order: 16; } /* Square: White on Transparent */

            /* Footer always last */
            footer { order: 99; }

            /* Ensure signature wrapper uses flex when visible on mobile too */
            .signature-input-wrapper.visible {
               display: flex;
            }
        }
    </style>
</head>

<body>
    <div class="container" id="mainContainer">
        <h2>Strategy Logo Maker</h2>
        <div class="text-input-wrapper">
            <input type="text" id="wordInput" value="More" placeholder="Enter text..." oninput="generateLogos()">
            <button id="signatureToggleBtn" title="Toggle Signature Input">📝</button>
        </div>
        <div class="signature-input-wrapper" id="signatureInputWrapper">
            <input type="text" id="signatureInput" value="" placeholder="Add Signature..." oninput="generateLogos()">
        </div>
        <div class="color-picker-container">
            <label class="color-picker-label" id="labelPicker1">
                <input type="color" id="colorPicker1" value="#000000" title="Color 1 (Default Black)" oninput="handleColorInput(this)">
            </label>
            <label class="color-picker-label" id="labelPicker2">
                <input type="color" id="colorPicker2" value="#FA660F" title="Color 2 (Default Orange)" oninput="handleColorInput(this)">
            </label>
            <label class="color-picker-label" id="labelPicker3">
                <input type="color" id="colorPicker3" value="#FFFFFF" title="Color 3 (Default White)" oninput="handleColorInput(this)">
            </label>
        </div>
        <!-- Canvas Rows remain the same structurally -->
        <div class="canvas-row">
            <canvas id="canvas1" width="1280" height="720"></canvas>
            <canvas id="canvas4" width="1280" height="720" class="transparent-bg"></canvas>
        </div>
        <div class="canvas-row">
            <canvas id="canvas2" width="1280" height="720"></canvas>
            <canvas id="canvas5" width="1280" height="720" class="transparent-bg"></canvas>
        </div>
        <div class="canvas-row">
            <canvas id="canvas3" width="1280" height="720"></canvas>
            <canvas id="canvas6" width="1280" height="720" class="transparent-bg"></canvas>
        </div>
        <div class="canvas-row">
            <canvas id="canvas7" width="1280" height="1280"></canvas>
            <canvas id="canvas10" width="1280" height="1280" class="transparent-bg"></canvas>
        </div>
        <div class="canvas-row">
            <canvas id="canvas8" width="1280" height="1280"></canvas>
            <canvas id="canvas11" width="1280" height="1280" class="transparent-bg"></canvas>
        </div>
        <div class="canvas-row">
            <canvas id="canvas9" width="1280" height="1280"></canvas>
            <canvas id="canvas12" width="1280" height="1280" class="transparent-bg"></canvas>
        </div>
        <footer>Made by <a href="https://x.com/LaDoger21"><b>@LaDoger21</b></a> with 🧡</footer>
    </div>

    <script>
        // --- JAVASCRIPT REMAINS EXACTLY THE SAME AS ORIGINAL VERSION 1 ---
        const COLOR_ROLE_1 = 'color1';
        const COLOR_ROLE_2 = 'color2';
        const COLOR_ROLE_3 = 'color3';

        const canvases = [
            { id: 'canvas1', textColorRole: COLOR_ROLE_1, bgColorRole: COLOR_ROLE_2 },
            { id: 'canvas4', textColorRole: COLOR_ROLE_1, bgColorRole: 'transparent' },
            { id: 'canvas2', textColorRole: COLOR_ROLE_2, bgColorRole: COLOR_ROLE_3 },
            { id: 'canvas5', textColorRole: COLOR_ROLE_2, bgColorRole: 'transparent' },
            { id: 'canvas3', textColorRole: COLOR_ROLE_3, bgColorRole: COLOR_ROLE_1 },
            { id: 'canvas6', textColorRole: COLOR_ROLE_3, bgColorRole: 'transparent' },
            { id: 'canvas7', textColorRole: COLOR_ROLE_1, bgColorRole: COLOR_ROLE_2 },
            { id: 'canvas10', textColorRole: COLOR_ROLE_1, bgColorRole: 'transparent' },
            { id: 'canvas8', textColorRole: COLOR_ROLE_2, bgColorRole: COLOR_ROLE_3 },
            { id: 'canvas11', textColorRole: COLOR_ROLE_2, bgColorRole: 'transparent' },
            { id: 'canvas9', textColorRole: COLOR_ROLE_3, bgColorRole: COLOR_ROLE_1 },
            { id: 'canvas12', textColorRole: COLOR_ROLE_3, bgColorRole: 'transparent' }
        ];

        const symbolImg = new Image();
        symbolImg.src = 'symbol.png';
        let symbolLoaded = false;
        symbolImg.onload = () => {
            symbolLoaded = true;
            // Ensure initial draw happens only once symbol is loaded or page is fully loaded
             if (document.readyState === 'complete' || document.readyState === 'interactive') {
                generateLogos();
            } else {
                 window.initialDrawTriggered = true; // Mark that it needs drawing on load
            }
        };
        symbolImg.onerror = () => console.error("Failed to load symbol.png");

        const offscreenCanvas = document.createElement('canvas');
        const offscreenCtx = offscreenCanvas.getContext('2d');
        const isMobile = () => window.innerWidth <= 600;
        const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
        const mainContainer = document.getElementById('mainContainer');
        window.initialDrawTriggered = false; // Used if symbol loads after initial page setup

        const signatureToggleBtn = document.getElementById('signatureToggleBtn');
        const signatureInputWrapper = document.getElementById('signatureInputWrapper');
        const signatureInput = document.getElementById('signatureInput');
        let isSignatureVisible = false;

        function getSelectedColors() {
            return {
                [COLOR_ROLE_1]: document.getElementById('colorPicker1').value,
                [COLOR_ROLE_2]: document.getElementById('colorPicker2').value,
                [COLOR_ROLE_3]: document.getElementById('colorPicker3').value
            };
        }

        function drawColorizedSymbol(mainCtx, targetColor, symbolX, symbolY, symbolWidth, symbolHeight) {
            if (!symbolLoaded || symbolWidth <= 0 || symbolHeight <= 0) return;
            try {
                // Ensure offscreen canvas dimensions are positive integers
                const osWidth = Math.max(1, Math.round(symbolWidth));
                const osHeight = Math.max(1, Math.round(symbolHeight));
                offscreenCanvas.width = osWidth;
                offscreenCanvas.height = osHeight;

                offscreenCtx.clearRect(0, 0, osWidth, osHeight);
                offscreenCtx.drawImage(symbolImg, 0, 0, osWidth, osHeight);
                offscreenCtx.globalCompositeOperation = 'source-in';
                offscreenCtx.fillStyle = targetColor;
                offscreenCtx.fillRect(0, 0, osWidth, osHeight);
                offscreenCtx.globalCompositeOperation = 'source-over'; // Reset composite operation
                mainCtx.drawImage(offscreenCanvas, symbolX, symbolY, symbolWidth, symbolHeight);
            } catch (e) {
                console.error("Error drawing symbol:", e);
                // Reset composite operation in case of error
                offscreenCtx.globalCompositeOperation = 'source-over';
            }
        }


        function updatePickerBackgrounds() {
            const colors = getSelectedColors();
            document.getElementById('labelPicker1').style.setProperty('--bg-color', colors[COLOR_ROLE_1]);
            document.getElementById('labelPicker2').style.setProperty('--bg-color', colors[COLOR_ROLE_2]);
            document.getElementById('labelPicker3').style.setProperty('--bg-color', colors[COLOR_ROLE_3]);
        }

        function handleColorInput(inputElement) {
            updatePickerBackgrounds();
            generateLogos();
        }

        function toggleSignatureInput() {
            isSignatureVisible = !isSignatureVisible;
            signatureInputWrapper.classList.toggle('visible', isSignatureVisible);
            signatureToggleBtn.classList.toggle('active', isSignatureVisible);
            // Only redraw if signature visibility changed *or* text exists
            // This avoids redraws when hiding an empty signature field
            if (isSignatureVisible || signatureInput.value.trim() !== '') {
                 generateLogos();
            }
            // Optional: Focus input when shown
            // if (isSignatureVisible) {
            //     signatureInput.focus();
            // }
        }


        function generateLogos() {
            // Delay drawing until symbol is loaded or considered loaded after timeout
             if (!symbolLoaded && !symbolImg.complete) {
                console.log("Symbol not loaded yet, queuing draw.");
                window.initialDrawTriggered = true; // Ensure it draws on load/timeout
                return;
            }

            requestAnimationFrame(() => {
                const input = document.getElementById('wordInput').value;
                const word = input ? input + "  " : ""; // Add space for symbol only if word exists
                const selectedColors = getSelectedColors();
                // Get signature text ONLY if the input is visible
                const signatureText = isSignatureVisible ? signatureInput.value.trim() : '';

                canvases.forEach(canvasInfo => {
                    const canvas = document.getElementById(canvasInfo.id);
                    if (!canvas) return;
                    const ctx = canvas.getContext('2d');
                    const textColor = selectedColors[canvasInfo.textColorRole];
                    const bgColor = canvasInfo.bgColorRole === 'transparent' ? 'transparent' : selectedColors[canvasInfo.bgColorRole];
                    const isSolidBackground = bgColor !== 'transparent';

                    // Clear canvas
                    ctx.clearRect(0, 0, canvas.width, canvas.height);

                    // Draw background if solid
                    if (isSolidBackground) {
                        ctx.fillStyle = bgColor;
                        ctx.fillRect(0, 0, canvas.width, canvas.height);
                    }

                    // Draw main text and symbol
                    if (word) { // Only draw if there's input text
                        const maxWidth = canvas.width * 0.9;
                        const maxHeight = canvas.height * 0.8; // Slightly less height allowance
                        let fontSize = Math.min(canvas.width / 5, canvas.height / 1.5); // Initial guess
                        let metrics, textWidth, textHeight;
                        let iterations = 0;
                        const maxIterations = 50; // Prevent infinite loops

                        // Function to set font and measure text
                        const setFontAndMeasure = (size) => {
                            ctx.font = `bold ${size}px Lexend`;
                            ctx.letterSpacing = `${size * -0.1}px`; // Apply letter spacing before measure
                            metrics = ctx.measureText(word);
                            // Estimate height based on font size and ascent/descent if available
                            textHeight = (metrics.actualBoundingBoxAscent || size * 0.8) + (metrics.actualBoundingBoxDescent || size * 0.2);
                            textWidth = metrics.width;
                        };

                        // Initial sizing
                        setFontAndMeasure(fontSize);

                        // Scale down if too large
                        while ((textWidth > maxWidth || textHeight > maxHeight) && fontSize > 10 && iterations < maxIterations) {
                            // Scale based on the dimension that's overflowing the most
                            fontSize *= Math.min(maxWidth / textWidth, maxHeight / textHeight) * 0.98; // Reduce slightly more aggressively
                            fontSize = Math.max(fontSize, 10); // Minimum font size
                            setFontAndMeasure(fontSize);
                            iterations++;
                        }

                        // Optional: Scale up slightly if too small (less aggressive)
                        iterations = 0; // Reset iteration count
                         while (textWidth < maxWidth * 0.7 && textHeight < maxHeight * 0.7 && fontSize < Math.min(canvas.width, canvas.height) * 0.8 && iterations < maxIterations) {
                            let scaleFactor = Math.min(maxWidth / textWidth, maxHeight / textHeight);
                            // Only scale up if the factor is significantly larger than 1
                             if (scaleFactor < 1.05) break;
                            fontSize *= Math.min(scaleFactor, 1.02); // Gentle scale up
                            setFontAndMeasure(fontSize);
                            iterations++;
                        }

                         // Final check to ensure it fits after potential scaling up
                         if (textWidth > maxWidth || textHeight > maxHeight) {
                             fontSize *= Math.min(maxWidth / textWidth, maxHeight / textHeight);
                             setFontAndMeasure(fontSize);
                         }


                        // --- Drawing ---
                        ctx.fillStyle = textColor;
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        const textY = canvas.height / 2;

                        // Calculate symbol position relative to the measured text ('input', not 'word')
                         ctx.font = `bold ${fontSize}px Lexend`; // Ensure font is set for measuring 'input'
                         ctx.letterSpacing = `${fontSize * -0.1}px`; // Keep consistent letter spacing
                         const inputMetrics = ctx.measureText(input);
                         const inputActualWidth = inputMetrics.width; // Use measured width

                        // Center the 'word' (text + space)
                        ctx.fillText(word, canvas.width / 2, textY);

                         // Symbol dimensions based on final font size
                         const symbolHeight = fontSize * 0.6;
                         const symbolAspectRatio = symbolImg.naturalWidth / symbolImg.naturalHeight || 534 / 889; // Use natural ratio, fallback
                         const symbolWidth = symbolHeight * symbolAspectRatio;

                         // Position symbol after the measured 'input' text, centered vertically
                         // X position: Center of canvas + half of input text width - adjustment for letter spacing influence
                         const symbolX = (canvas.width / 2) + (inputActualWidth / 2) - (fontSize * 0.1); // Adjust slightly left
                         // Y position: Vertically aligned with text middle, shifted down slightly, then adjusted by symbol height
                         const downwardShiftFactor = 0.08;
                         const symbolBottomY = textY + (fontSize * downwardShiftFactor);
                         const symbolY = symbolBottomY - symbolHeight;

                        // Draw the colorized symbol
                         if (symbolLoaded) {
                             drawColorizedSymbol(ctx, textColor, symbolX, symbolY, symbolWidth, symbolHeight);
                         }
                    }

                    // Draw signature if conditions met
                    if (signatureText && isSolidBackground) { // Only draw if text exists and background is solid
                        ctx.fillStyle = textColor; // Use main text color for signature
                        ctx.font = '400 40px Inter'; // Signature font
                        ctx.textAlign = 'right';
                        ctx.textBaseline = 'bottom';
                        ctx.letterSpacing = '0px'; // Reset letter spacing for signature
                        const padding = 30; // Padding from edges
                        const sigX = canvas.width - padding;
                        const sigY = canvas.height - padding;
                        ctx.fillText(signatureText, sigX, sigY);
                    }
                    // Reset any context properties that might affect next draw
                    ctx.letterSpacing = '0px';
                });
            });
        }


        function setupCanvasClickEvents() {
            canvases.forEach(canvasInfo => {
                const canvas = document.getElementById(canvasInfo.id);
                if (!canvas) return;
                canvas.onclick = null; // Remove previous listener

                if (isMobile()) {
                    canvas.style.cursor = 'pointer'; // Add pointer cursor on mobile
                    canvas.onclick = () => {
                        try {
                            const dataUrl = canvas.toDataURL('image/png');
                            const word = document.getElementById('wordInput').value.trim().replace(/[^a-z0-9]/gi, '-') || 'Logo'; // Sanitize filename part
                            const aspectRatio = canvas.width === canvas.height ? 'SQ' : '16x9';
                            const selectedColors = getSelectedColors();
                            const textColor = selectedColors[canvasInfo.textColorRole];
                            const bgColor = canvasInfo.bgColorRole === 'transparent' ? 'transparent' : selectedColors[canvasInfo.bgColorRole];
                            const sigText = isSignatureVisible ? signatureInput.value.trim() : '';
                            const isSolidBg = bgColor !== 'transparent';
                            const sigPart = (sigText && isSolidBg) ? `_sig-${sigText.replace(/[^a-z0-9]/gi, '')}` : '';
                            // Sanitize color codes for filename
                            const cleanTextColor = textColor.replace('#', '');
                            const cleanBgColor = bgColor === 'transparent' ? 'transp' : bgColor.replace('#', '');

                            const filename = `${word}_${cleanTextColor}-on-${cleanBgColor}_${aspectRatio}${sigPart}.png`;

                            if (isIOS && navigator.share) {
                                // Use Share API on iOS if available
                                fetch(dataUrl)
                                    .then(res => res.blob())
                                    .then(blob => {
                                        if (!blob) throw new Error("Blob creation failed");
                                        if (!navigator.canShare || !navigator.canShare({ files: [new File([blob], filename, { type: 'image/png' })] })) {
                                             throw new Error("Sharing not supported for this file type.");
                                        }
                                        navigator.share({
                                            files: [new File([blob], filename, { type: 'image/png' })],
                                            title: filename // Optional title
                                        })
                                        .catch(error => {
                                            console.error('Share API failed:', error);
                                            // Fallback to opening in new tab if share fails
                                            window.open(dataUrl, '_blank');
                                        });
                                    })
                                    .catch(error => {
                                        console.error('Fetch/Blob/Share Setup failed:', error);
                                        // Fallback for fetch/blob errors or if sharing isn't supported
                                        window.open(dataUrl, '_blank');
                                    });
                            } else if (isIOS) {
                                // Fallback for older iOS or non-shareable scenarios: Open in new tab
                                window.open(dataUrl, '_blank');
                            } else {
                                // Standard download for non-iOS browsers
                                const link = document.createElement('a');
                                link.download = filename;
                                link.href = dataUrl;
                                document.body.appendChild(link);
                                link.click();
                                document.body.removeChild(link);
                            }
                        } catch (e) {
                            console.error("Error generating or downloading canvas image:", e);
                            alert("Could not generate download link. Your browser might not support this feature or the canvas is empty.");
                        }
                    };
                } else {
                    // Optional: Add hover effect or title for desktop?
                    canvas.style.cursor = ''; // Default cursor on desktop
                    // Desktop could have right-click save, or a dedicated download button per canvas if needed.
                }
            });
        }


        function resizeHandler() {
            const container = mainContainer;
            const totalWidth = Math.min(800, container.clientWidth); // Max width constraint
            const gap = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--standard-gap')) || 12; // Use var, fallback
            const smallScreen = isMobile();

            canvases.forEach(canvasInfo => {
                const canvas = document.getElementById(canvasInfo.id);
                if (!canvas) return;

                let canvasContainerWidth;
                 if (smallScreen) {
                     // On mobile (grid), canvas takes full container width minus padding
                     canvasContainerWidth = container.clientWidth;
                 } else {
                     // On desktop (flex rows), each canvas takes roughly half width minus gap
                     canvasContainerWidth = (totalWidth - gap) / 2;
                 }

                const displayWidth = Math.max(10, Math.floor(canvasContainerWidth)); // Ensure positive integer width
                const nativeRatio = canvas.height / canvas.width; // Use canvas element's dimensions
                const displayHeight = Math.floor(displayWidth * nativeRatio); // Calculate height based on aspect ratio

                // Update display style size
                canvas.style.width = `${displayWidth}px`;
                canvas.style.height = `${displayHeight}px`;
            });

            // Trigger redraw after resizing canvases
            generateLogos();
            // Update click events based on new mobile status
            setupCanvasClickEvents();
        }

        // --- Initialization ---
        window.addEventListener('load', () => {
             // Set initial state
             if (symbolImg.complete && symbolImg.naturalWidth > 0) {
                 symbolLoaded = true;
             }
             updatePickerBackgrounds(); // Set initial picker colors
             resizeHandler(); // Initial layout and draw

             // Event Listeners
             signatureToggleBtn.addEventListener('click', toggleSignatureInput);

             let resizeTimeout;
             window.addEventListener('resize', () => {
                 clearTimeout(resizeTimeout);
                 resizeTimeout = setTimeout(() => {
                     // Check mobile status again after resize might change it
                     resizeHandler();
                 }, 150); // Debounce resize events
             });

             // Fallback timer in case symbol onload doesn't fire or is very slow
             setTimeout(() => {
                 if (!symbolLoaded) {
                     console.warn("Symbol image load timeout. Assuming loaded or failed, attempting draw.");
                     symbolLoaded = true; // Assume it's loaded or failed, allow drawing
                     generateLogos(); // Attempt draw anyway
                 }
             }, 3000); // 3-second timeout

             // Ensure draw happens if symbol loaded after initial load event but before timeout
             if (window.initialDrawTriggered && symbolLoaded) {
                 generateLogos();
             }
        });

    </script>
</body>
</html>